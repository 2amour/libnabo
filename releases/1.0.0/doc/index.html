<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libnabo1: libnabo</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libnabo1&#160;<span id="projectnumber">1.0.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>libnabo </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>from <a href="http://github.com/stephanemagnenat/libnabo">http://github.com/stephanemagnenat/libnabo</a> by Stéphane Magnenat (<a href="http://stephane.magnenat.net">http://stephane.magnenat.net</a>), ASL-ETHZ, Switzerland (<a href="http://www.asl.ethz.ch">http://www.asl.ethz.ch</a>)</p>
<p>libnabo is a fast K Nearest Neighbour library for low-dimensional spaces. It provides a clean, legacy-free, scalar-type–agnostic API thanks to C++ templates. Its current CPU implementation is strongly inspired by <a class="el" href="index.html#ANN">ANN</a>, but with more compact data types. On the average, libnabo is 5% to 20% faster than <a class="el" href="index.html#ANN">ANN</a>.</p>
<p>libnabo depends on <a class="el" href="index.html#Eigen">Eigen</a>, a modern C++ matrix and linear-algebra library. libnabo works with either version 2 or 3 of Eigen. libnabo also depends on <a class="el" href="index.html#Boost">Boost</a>, a C++ general library.</p>
<h2><a class="anchor" id="Compilation"></a>
Compilation</h2>
<p>libnabo uses <a class="el" href="index.html#CMake">CMake</a> as build system. The complete compilation process depends on the system you are using (Linux, Mac OS X or Windows). You will find a nice introductory tutorial in this you tube video: <a href="http://www.youtube.com/watch?v=CLvZTyji_Uw.">http://www.youtube.com/watch?v=CLvZTyji_Uw.</a></p>
<h3><a class="anchor" id="Prerequisites"></a>
Prerequisites</h3>
<p>If your operating system does not provide it, you must get <a class="el" href="index.html#Eigen">Eigen</a> and <a class="el" href="index.html#Boost">Boost</a>. <a class="el" href="index.html#Eigen">Eigen</a> only needs to be downloaded and extracted.</p>
<h3><a class="anchor" id="QuickCompilationUnix"></a>
Quick compilation and installation under Unix</h3>
<p>Under Unix, assuming that <a class="el" href="index.html#Eigen">Eigen</a> and <a class="el" href="index.html#Boost">Boost</a> are installed system-wide, you can compile (with optimisation and debug information) and install libnabo in <code>/usr/local</code> with the following commands run in the top-level directory of libnabo's sources: </p>
<div class="fragment"><pre class="fragment">SRC_DIR=`pwd`
BUILD_DIR=${SRC_DIR}/build
mkdir -p ${BUILD_DIR} &amp;&amp; cd ${BUILD_DIR}
cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo ${SRC_DIR}
<span class="preprocessor"># if Eigen or Boost are not available system-wide, run at that point: </span>
<span class="preprocessor"></span><span class="preprocessor">#   cmake-gui .</span>
<span class="preprocessor"></span><span class="preprocessor"># cmake-gui allows you to tell the location of Eigen or Boost</span>
<span class="preprocessor"></span>make
sudo make install
</pre></div><p>These lines will compile libnabo in a <code>build</code> sub-directory and therefore keep your source tree clean. Note that you could compile libnabo anywhere you have write access, such as in <code>/tmp/libnabo</code>. This out-of-source build is a nice feature of <a class="el" href="index.html#CMake">CMake</a>.</p>
<p>If <a class="el" href="index.html#Eigen">Eigen</a> or <a class="el" href="index.html#Boost">Boost</a> are not installed system-wide, you might have to tell <a class="el" href="index.html#CMake">CMake</a> where to find them. You can do this with a command-line tool, <code>ccmake</code>, or with a graphical tool, <code>cmake-gui</code>. Please read the <a href="http://www.cmake.org/cmake/help/cmake2.6docs.html">CMake documentation</a> for more information.</p>
<p>You can generate the documentation by typing: </p>
<div class="fragment"><pre class="fragment">make doc
</pre></div><h2><a class="anchor" id="Usage"></a>
Usage</h2>
<p>libnabo is easy to use. For example, assuming that you are working with floats and that you have a point set <code>M</code> and a query point <code>q</code>, you can find the <code>K</code> nearest neighbours of <code>q</code> in <code>M</code> :</p>
<div class="fragment"><pre class="fragment"><span class="comment">// This example is in the public domain</span>

<span class="preprocessor">#include &quot;<a class="code" href="nabo_8h.html" title="public interface">nabo/nabo.h</a>&quot;</span>

<span class="keywordtype">int</span> main()
{
        <span class="keyword">using namespace </span>Nabo;
        <span class="keyword">using namespace </span>Eigen;
        
        <span class="comment">// 100 points in 3D</span>
        MatrixXf M = MatrixXf::Random(3, 100);
        <span class="comment">// 1 query points</span>
        VectorXf q = VectorXf::Random(3);
        
        <span class="comment">// create a kd-tree for M, note that M must stay valid during the lifetime of the kd-tree</span>
        <a class="code" href="structNabo_1_1NearestNeighbourSearch.html" title="Nearest neighbour search interface, templatized on scalar type.">NNSearchF</a>* nns = <a class="code" href="structNabo_1_1NearestNeighbourSearch.html#a83a4ef4bdcf4f245352c630011090584" title="Create a nearest-neighbour search, using a kd-tree with linear heap, good for small k (~up to 30)...">NNSearchF::createKDTreeLinearHeap</a>(M);
        
        <span class="comment">// look for the 5 nearest neighbour of a the single-point query</span>
        <span class="keyword">const</span> <span class="keywordtype">int</span> K = 5;
        VectorXi indices(K);
        VectorXf dists2(K);
        nns-&gt;knn(q, indices, dists2, K);
        
        <span class="comment">// cleanup kd-tree</span>
        <span class="keyword">delete</span> nns;
        
        <span class="keywordflow">return</span> 0;
}
</pre></div><p>In this example, <code>M</code> is an <a class="el" href="index.html#Eigen">Eigen</a> (refering to the software, not to the math) matrix (column major, float) and <code>q</code> is an <a class="el" href="index.html#Eigen">Eigen</a> vector (float). The results <code>indices</code> and <code>dists2</code> are <a class="el" href="index.html#Eigen">Eigen</a> vectors of indices and squared distances refering to the columns of <code>M</code>.</p>
<p>Here is a slightly more complex example:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// This example is in the public domain</span>

<span class="preprocessor">#include &quot;<a class="code" href="nabo_8h.html" title="public interface">nabo/nabo.h</a>&quot;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keywordtype">int</span> main()
{
        <span class="keyword">using namespace </span>Nabo;
        <span class="keyword">using namespace </span>Eigen;
        <span class="keyword">using namespace </span>std;
        
        <span class="comment">// 100 points in 3D</span>
        MatrixXf M = MatrixXf::Random(3, 100);
        <span class="comment">// 50 query points</span>
        MatrixXf q = MatrixXf::Random(3, 50);
        
        <span class="comment">// Create a kd-tree for M, note that M must stay valid during the lifetime of the kd-tree.</span>
        <a class="code" href="structNabo_1_1NearestNeighbourSearch.html" title="Nearest neighbour search interface, templatized on scalar type.">NNSearchF</a>* nns = <a class="code" href="structNabo_1_1NearestNeighbourSearch.html#a83a4ef4bdcf4f245352c630011090584" title="Create a nearest-neighbour search, using a kd-tree with linear heap, good for small k (~up to 30)...">NNSearchF::createKDTreeLinearHeap</a>(M);
        
        <span class="comment">// The output of the query are a matrix of indices to columns of M and </span>
        <span class="comment">// a matrix of squared distances corresponding to these indices.</span>
        <span class="comment">// These matrix must have the correct size when passed to the search function.</span>
        MatrixXi indices;
        MatrixXf dists2;
        
        <span class="comment">// Look for the 5 nearest neighbours of each query point, </span>
        <span class="comment">// We do not want approximations but we want to sort by the distance,</span>
        indices.resize(5, q.cols());
        dists2.resize(5, q.cols());
        nns-&gt;knn(q, indices, dists2, 5, 0, <a class="code" href="structNabo_1_1NearestNeighbourSearch.html#a4d38e811608982919bd6760f52cd21b3a408d6d6af613aeac8ab2fc9dbcf5cd23" title="sort points by distances, when k &amp;gt; 1; do not sort by default">NNSearchF::SORT_RESULTS</a>);
        
        <span class="comment">// Look for the 3 nearest neighbours of each query point, use the data themselves for the query.</span>
        <span class="comment">// We do not want approximations but we want to sort by the distance,</span>
        <span class="comment">// and we want to allow self-match.</span>
        indices.resize(3, M.cols());
        dists2.resize(3, M.cols());
        nns-&gt;knn(M, indices, dists2, 3, 0, <a class="code" href="structNabo_1_1NearestNeighbourSearch.html#a4d38e811608982919bd6760f52cd21b3a408d6d6af613aeac8ab2fc9dbcf5cd23" title="sort points by distances, when k &amp;gt; 1; do not sort by default">NNSearchF::SORT_RESULTS</a> | <a class="code" href="structNabo_1_1NearestNeighbourSearch.html#a4d38e811608982919bd6760f52cd21b3acf39c08e8b31b13726fc368c5d28df0c" title="allows the return of the same point as the query, if this point is in the data cloud; forbidden by de...">NNSearchF::ALLOW_SELF_MATCH</a>);
        
        <span class="comment">// Make sure that the closest return points correspond to the points from M.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; ++i)
        {
                <span class="comment">// The query is the data itself and we allow self-match.</span>
                <span class="keywordflow">if</span> (indices.coeff(0, i) != i)
                        cerr &lt;&lt; <span class="stringliteral">&quot;Oups, something went wrong: &quot;</span> &lt;&lt; indices.coeff(0, i) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;  i &lt;&lt; endl;
        }
        
        <span class="comment">// Now look for the 2 nearset neighbours of each query point.</span>
        <span class="comment">// We do allow 10% approximation but do not want to allow self-match.</span>
        <span class="comment">// We do not care about sorting either.</span>
        indices.resize(2, M.cols());
        dists2.resize(2, M.cols());
        nns-&gt;knn(M, indices, dists2, 2, 0.1, 0);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 50; ++i)
        {
                <span class="comment">// The query is the data itself but we forbide self-match.</span>
                <span class="keywordflow">if</span> (indices.coeff(0, i) == i)
                        cerr &lt;&lt; <span class="stringliteral">&quot;Oups, something went wrong: &quot;</span> &lt;&lt; indices.coeff(0, i) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;  i &lt;&lt; endl;
        }
        
        <span class="comment">// Cleanup the kd-tree.</span>
        <span class="keyword">delete</span> nns;
        
        <span class="keywordflow">return</span> 0;
}
</pre></div><p>Note that the matrix-based interface for query is more efficient than the vector-based one, because some sanity checks can be done only once. Therefore, if you have multiple points to query, we warmly suggest to pass them as a matrix instead of calling <code>knn()</code> multiple times.</p>
<h2><a class="anchor" id="ConstructionParameters"></a>
Construction parameters</h2>
<p>The following additional construction parameters are available in KDTREE_ algorithms:</p>
<ul>
<li><code>bucketSize</code> (<code>unsigned</code>): bucket size, defaults to 8</li>
</ul>
<h2><a class="anchor" id="UnitTesting"></a>
Unit testing</h2>
<p>The distribution of libnabo integrates a unit test module, based on CTest. Just type:</p>
<div class="fragment"><pre class="fragment">make test
</pre></div><p>...in the build directory to run the tests. Their outputs are available in the <code>Testing</code> directory. These consist of validation and benchmarking tests. If <a class="el" href="index.html#ANN">ANN</a> is detected when compiling libnabo, <code>make</code> <code>test</code> will also perform comparative benchmarks.</p>
<h2><a class="anchor" id="BugReporting"></a>
Bug reporting</h2>
<p>Please use <a href="http://github.com/ethz-asl/libnabo/issues">github's issue tracker</a> to report bugs.</p>
<h2><a class="anchor" id="License"></a>
License</h2>
<p>libnabo is released under a permissive BSD license.</p>
<h2><a class="anchor" id="Faq"></a>
Faq</h2>
<h3><a class="anchor" id="ANN"></a>
ANN</h3>
<p>libnabo differs from <a class="el" href="index.html#ANN">ANN</a> on the following points:</p>
<p>API</p>
<ul>
<li>templates for scalar type</li>
<li>self-match option as execution-time (instead of compile-time) parameter</li>
<li>range search instead of radius search</li>
<li><a class="el" href="index.html#Eigen">Eigen</a> library for vector and matrixes</li>
<li>reentrant</li>
</ul>
<p>limitations</p>
<ul>
<li>only euclidean distance</li>
<li>only KD-tree, no BD-tree</li>
<li>only ANN_KD_SL_MIDPT splitting rules</li>
</ul>
<p>implementation</p>
<ul>
<li>optional O(log(n)) tree heap instead of O(n) vector heap</li>
<li>compact memory representation, one memory allocation for all nodes, 5-fold smaller memory footprint compared than ANN</li>
<li>implicit reference to left child (always next node in array)</li>
<li>do not store bounds in nodes (that is, I do it like in ANN's article instead of like in ANN's source code)</li>
</ul>
<p>performances</p>
<ul>
<li>about 5% to 20% faster than ANN (both -O3 -NDEBUG), probably due to the smaller memory footprint</li>
<li>clearly memory-bound, neither OpenMP nor boost::thread improve performances</li>
</ul>
<h2><a class="anchor" id="References"></a>
References</h2>
<ul>
<li><a class="anchor" id="Eigen"></a> Eigen: <a href="http://eigen.tuxfamily.org">http://eigen.tuxfamily.org</a> </li>
<li><a class="anchor" id="ANN"></a> ANN: <a href="http://www.cs.umd.edu/~mount/ANN">http://www.cs.umd.edu/~mount/ANN</a> </li>
<li><a class="anchor" id="CMake"></a> CMake: <a href="http://www.cmake.org">http://www.cmake.org</a> </li>
<li><a class="anchor" id="Boost"></a> Boost: <a href="http://www.boost.org">http://www.boost.org</a> </li>
</ul>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Oct 18 2011 16:17:57 for libnabo1 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
